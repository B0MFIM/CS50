MEMORY

    HEXADECIMAL

        HEXADECIMAL É UM SISTEMA NUMÉRICO DE BASE 16, QUE UTILIZA OS DÍGITOS DE 0 A 9 E AS LETRAS DE A A F PARA 
        REPRESENTAR VALORES. É FREQUENTEMENTE USADO EM PROGRAMAÇÃO E COMPUTAÇÃO PARA SIMPLIFICAR A REPRESENTAÇÃO 
        DE VALORES BINÁRIOS LONGOS.

        EXEMPLO:

            16  1   
            #   #   ->  09 = 9 | 0A = 10 | 0F = 16 | 1F = 32 | FF = 255

        POR QUE HEXADECIMAL É ÚTIL?

        HEXADECIMAL É ÚTIL PORQUE SIMPLIFICA A LEITURA E A ESCRITA DE VALORES BINÁRIOS LONGOS. EM VEZ DE LIDAR COM 
        UMA LONGA SEQUÊNCIA DE 0'S E 1'S, PODEMOS USAR MENOS DÍGITOS HEXADECIMAIS PARA REPRESENTAR O MESMO VALOR. 
        POR EXEMPLO, DOIS BYTES EM BINÁRIO (16 BITS) PODEM SER REPRESENTADOS COMO 4 DÍGITOS HEXADECIMAIS. ISSO 
        TORNA MAIS FÁCIL A VISUALIZAÇÃO E A MANIPULAÇÃO DOS DADOS.

        EXEMPLO:

            BINÁRIO:  1101 1010 0110 1111
            HEXADECIMAL: DA6F

        PARA FACILITAR A IDENTIFICAÇÃO DE NÚMEROS HEXADECIMAIS EM CÓDIGOS FONTE, É COMUM UTILIZAR O PREFIXO "0x" 
        ANTES DO NÚMERO. ISSO AJUDA A DIFERENCIAR NÚMEROS HEXADECIMAIS DE OUTROS TIPOS DE NÚMEROS, COMO DECIMAIS 
        OU OCTAIS.

        EXEMPLO:

            0x1A3F  ->  REPRESENTA O NÚMERO HEXADECIMAL 1A3F (6719 EM DECIMAL)
            0xFF    ->  REPRESENTA O NÚMERO HEXADECIMAL FF (255 EM DECIMAL)


    POINTERS

        EM C, UM PONTEIRO É UMA VARIÁVEL QUE ARMAZENA O ENDEREÇO DE MEMÓRIA DE OUTRA VARIÁVEL. ISSO PERMITE QUE VOCÊ 
        MANIPULE DIRETAMENTE OS VALORES NA MEMÓRIA, O QUE PODE SER MUITO PODEROSO E EFICIENTE.

        DECLARANDO PONTEIROS:

            TIPO *NOME_DO_PONTEIRO;

        EXEMPLO:

            int *ptr;

        AQUI, `ptr` É UM PONTEIRO PARA UM INTEIRO. ISSO SIGNIFICA QUE `ptr` PODE ARMAZENAR O ENDEREÇO DE MEMÓRIA DE 
        UMA VARIÁVEL INTEIRA.

        ATRIBUINDO ENDEREÇOS:

            int var = 10;
            int *ptr = &var;

        AQUI, `ptr` ARMAZENA O ENDEREÇO DE MEMÓRIA DE `var`. O OPERADOR `&` É USADO PARA OBTER O ENDEREÇO DE MEMÓRIA 
        DE UMA VARIÁVEL.

        ACESSANDO VALORES:

            int valor = *ptr;

        AQUI, `valor` RECEBE O VALOR ARMAZENADO NO ENDEREÇO DE MEMÓRIA APONTADO POR `ptr`. O OPERADOR `*` É USADO 
        PARA DESREFERENCIAR O PONTEIRO, OU SEJA, ACESSAR O VALOR ARMAZENADO NAQUELE ENDEREÇO.

        PONTEIROS SÃO EXTREMAMENTE ÚTEIS EM C PARA UMA VARIEDADE DE TAREFAS, INCLUINDO ALOCAÇÃO DINÂMICA DE MEMÓRIA, 
        PASSAGEM DE PARÂMETROS POR REFERÊNCIA E MANIPULAÇÃO DE ARRAYS E STRINGS.

        O OPERADOR `&` TAMBÉM É USADO PARA PASSAR PARÂMETROS POR REFERÊNCIA EM FUNÇÕES.

        EXEMPLO:
        
            int n = 50;
            printf("%p\n", &n);
        
        SE DECLARA UMA VARIÁVEL INTEIRA `N` E A INICIALIZA COM O VALOR 50.
        E IMPRIME O ENDEREÇO DE MEMÓRIA DA VARIÁVEL `N` USANDO O ESPECIFICADOR DE FORMATO `%P`.
        `%P` É UM ESPECIFICADOR DE FORMATO USADO PARA IMPRIMIR O VALOR DE UM POINTER.
        O OPERADOR `&`, É USADO PARA OBTER O ENDEREÇO DE MEMÓRIA DE UMA VARIÁVEL.
        

    STRINGS

        EM C, STRINGS NÃO SÃO UM TIPO DE DADO PRIMITIVO COMO EM OUTRAS LINGUAGENS DE PROGRAMAÇÃO. EM VEZ DISSO, 
        STRINGS SÃO REPRESENTADAS COMO ARRAYS DE CARACTERES TERMINADOS COM UM CARACTERE NULO (`\0`).

        DECLARANDO STRINGS:

            char nome[] = "CS50";

        AQUI, `nome` É UM ARRAY DE CARACTERES QUE CONTÉM A STRING "CS50" E UM CARACTERE NULO (`\0`) NO FINAL.

        STRINGS E PONTEIROS:

        EM C, STRINGS SÃO FORTEMENTE RELACIONADAS A PONTEIROS. UM PONTEIRO PARA UM CHAR (`char *`) PODE SER USADO 
        PARA MANIPULAR STRINGS.

        EXEMPLO:

            char *nome = "CS50";

        AQUI, `nome` É UM PONTEIRO PARA UM CHAR QUE APONTA PARA A STRING "CS50". ESSA É UMA FORMA COMUM DE 
        DECLARAR STRINGS EM C.

        ACESSANDO E MODIFICANDO STRINGS:

        VOCÊ PODE USAR PONTEIROS PARA ACESSAR E MODIFICAR OS CARACTERES EM UMA STRING.

        EXEMPLO:

            char nome[] = "CS50";
            char *ptr = nome;
            ptr[0] = 'c';

        AQUI, `ptr` APONTA PARA O PRIMEIRO CARACTERE DA STRING `nome`. AO MODIFICAR `ptr[0]`, VOCÊ TAMBÉM MODIFICA 
        O PRIMEIRO CARACTERE DA STRING `nome`.

        POR QUE STRINGS NÃO SÃO UM TIPO DE DADO EM C?

        STRINGS NÃO SÃO UM TIPO DE DADO PRIMITIVO EM C PORQUE A LINGUAGEM FOI PROJETADA PARA SER SIMPLES E EFICIENTE. 
        AO USAR ARRAYS DE CARACTERES E PONTEIROS, C FORNECE UMA FORMA FLEXÍVEL E PODEROSA DE MANIPULAR STRINGS SEM 
        A SOBRECARGA DE UM TIPO DE DADO DEDICADO. ISSO TAMBÉM PERMITE QUE OS PROGRAMADORES TENHAM MAIS CONTROLE 
        SOBRE A MEMÓRIA E O DESEMPENHO DE SEUS PROGRAMAS.
    

    USANDO `typedef` COM PONTEIROS:

        O `typedef` EM C PERMITE CRIAR NOMES ALTERNATIVOS PARA TIPOS DE DADOS EXISTENTES, O QUE PODE TORNAR O CÓDIGO 
        MAIS LEGÍVEL E MANUTENÍVEL. ISSO É PARTICULARMENTE ÚTIL QUANDO SE TRATA DE PONTEIROS.

        EXEMPLO:

            typedef int* IntPtr;

        AQUI, `IntPtr` É DEFINIDO COMO UM NOME ALTERNATIVO PARA `int*`. ISSO SIGNIFICA QUE VOCÊ PODE USAR `IntPtr` 
        EM VEZ DE `int*` AO DECLARAR PONTEIROS PARA INTEIROS:

            IntPtr ptr1, ptr2;

        NESTE EXEMPLO, `ptr1` E `ptr2` SÃO DECLARADOS COMO PONTEIROS PARA INTEIROS USANDO O NOME ALTERNATIVO `IntPtr`.

    USANDO `typedef` COM STRINGS:

        ASSIM COMO COM PONTEIROS, VOCÊ PODE USAR `typedef` PARA CRIAR NOMES ALTERNATIVOS PARA STRINGS. EM C, STRINGS 
        SÃO REPRESENTADAS COMO PONTEIROS PARA CHAR (`char*`), E USAR `typedef` PODE TORNAR O CÓDIGO MAIS CLARO.

        EXEMPLO:

            typedef char* string;

        AQUI, `string` É DEFINIDO COMO UM NOME ALTERNATIVO PARA `char*`. ISSO SIGNIFICA QUE VOCÊ PODE USAR `string` 
        EM VEZ DE `char*` AO DECLARAR STRINGS:

            string nome = "CS50";

        NESTE EXEMPLO, `nome` É DECLARADO COMO UMA STRING USANDO O NOME ALTERNATIVO `string`.

        O `typedef` É UMA FERRAMENTA PODEROSA EM C QUE PODE AJUDAR A SIMPLIFICAR E CLARIFICAR O CÓDIGO, ESPECIALMENTE 
        QUANDO SE TRATA DE TIPOS COMPLEXOS. AO USAR `typedef`, VOCÊ PODE CRIAR NOMES MAIS SIGNIFICATIVOS E REDUZIR 
        A COMPLEXIDADE VISUAL DO SEU CÓDIGO.


    POINTER ARITHMETIC

        EM C, A ARITMÉTICA DE PONTEIROS PERMITE QUE VOCÊ REALIZE OPERAÇÕES MATEMÁTICAS COM PONTEIROS, COMO ADIÇÃO E 
        SUBTRAÇÃO. ISSO É PARTICULARMENTE ÚTIL AO TRABALHAR COM ARRAYS E STRINGS.

        EXEMPLO:

            char s[] = "CS50";
            printf("%c\n", *(s + 1)); // Imprime 'S'
            printf("%c\n", s[1]);     // Imprime 'S'

        AQUI, `s` É UM ARRAY DE CARACTERES QUE CONTÉM A STRING "CS50". AO USAR `*(s + 1)`, ESTAMOS ACESSANDO O 
        SEGUNDO CARACTERE DA STRING (ÍNDICE 1), QUE É 'S'. ISSO É EQUIVALENTE A USAR `s[1]`.

        OUTRO EXEMPLO:

            int arr[] = {10, 20, 30, 40};
            int *ptr = arr;
            printf("%d\n", *(ptr + 2)); // Imprime 30
            printf("%d\n", arr[2]);     // Imprime 30

        AQUI, `arr` É UM ARRAY DE INTEIROS. AO USAR `*(ptr + 2)`, ESTAMOS ACESSANDO O TERCEIRO ELEMENTO DO ARRAY 
        (ÍNDICE 2), QUE É 30. ISSO É EQUIVALENTE A USAR `arr[2]`.

        A ARITMÉTICA DE PONTEIROS TAMBÉM PODE SER USADA PARA ITERAR SOBRE ARRAYS E STRINGS.

        EXEMPLO:

            char s[] = "CS50";
            char *ptr = s;
            while (*ptr != '\0') {
                printf("%c\n", *ptr);
                ptr++;
            }

        AQUI, `ptr` É UM PONTEIRO QUE INICIALMENTE APONTA PARA O PRIMEIRO CARACTERE DA STRING `s`. O LOOP `while` 
        IMPRIME CADA CARACTERE DA STRING ATÉ ENCONTRAR O CARACTERE NULO (`\0`), INCREMENTANDO `ptr` A CADA ITERAÇÃO.

        A ARITMÉTICA DE PONTEIROS É UMA FERRAMENTA PODEROSA EM C QUE PERMITE MANIPULAR DIRETAMENTE OS ENDEREÇOS DE 
        MEMÓRIA E TRABALHAR EFICIENTEMENTE COM ARRAYS E STRINGS. NO ENTANTO, É IMPORTANTE USAR ESSA FERRAMENTA COM 
        CUIDADO PARA EVITAR ERROS DE ACESSO À MEMÓRIA.
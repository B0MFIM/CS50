MEMORY

    HEXADECIMAL

        HEXADECIMAL É UM SISTEMA NUMÉRICO DE BASE 16, QUE UTILIZA OS DÍGITOS DE 0 A 9 E AS LETRAS DE A A F PARA 
        REPRESENTAR VALORES. É FREQUENTEMENTE USADO EM PROGRAMAÇÃO E COMPUTAÇÃO PARA SIMPLIFICAR A REPRESENTAÇÃO 
        DE VALORES BINÁRIOS LONGOS.

        EXEMPLO:

            16  1   
            #   #   ->  09 = 9 | 0A = 10 | 0F = 16 | 1F = 32 | FF = 255

        POR QUE HEXADECIMAL É ÚTIL?

        HEXADECIMAL É ÚTIL PORQUE SIMPLIFICA A LEITURA E A ESCRITA DE VALORES BINÁRIOS LONGOS. EM VEZ DE LIDAR COM 
        UMA LONGA SEQUÊNCIA DE 0'S E 1'S, PODEMOS USAR MENOS DÍGITOS HEXADECIMAIS PARA REPRESENTAR O MESMO VALOR. 
        POR EXEMPLO, DOIS BYTES EM BINÁRIO (16 BITS) PODEM SER REPRESENTADOS COMO 4 DÍGITOS HEXADECIMAIS. ISSO 
        TORNA MAIS FÁCIL A VISUALIZAÇÃO E A MANIPULAÇÃO DOS DADOS.

        EXEMPLO:

            BINÁRIO:  1101 1010 0110 1111
            HEXADECIMAL: DA6F

        PARA FACILITAR A IDENTIFICAÇÃO DE NÚMEROS HEXADECIMAIS EM CÓDIGOS FONTE, É COMUM UTILIZAR O PREFIXO "0x" 
        ANTES DO NÚMERO. ISSO AJUDA A DIFERENCIAR NÚMEROS HEXADECIMAIS DE OUTROS TIPOS DE NÚMEROS, COMO DECIMAIS 
        OU OCTAIS.

        EXEMPLO:

            0x1A3F  ->  REPRESENTA O NÚMERO HEXADECIMAL 1A3F (6719 EM DECIMAL)
            0xFF    ->  REPRESENTA O NÚMERO HEXADECIMAL FF (255 EM DECIMAL)


    POINTERS

        EM C, UM PONTEIRO É UMA VARIÁVEL QUE ARMAZENA O ENDEREÇO DE MEMÓRIA DE OUTRA VARIÁVEL. ISSO PERMITE QUE VOCÊ 
        MANIPULE DIRETAMENTE OS VALORES NA MEMÓRIA, O QUE PODE SER MUITO PODEROSO E EFICIENTE.

        DECLARANDO PONTEIROS:

            TIPO *NOME_DO_PONTEIRO;

        EXEMPLO:

            int *ptr;

        AQUI, `ptr` É UM PONTEIRO PARA UM INTEIRO. ISSO SIGNIFICA QUE `ptr` PODE ARMAZENAR O ENDEREÇO DE MEMÓRIA DE 
        UMA VARIÁVEL INTEIRA.

        ATRIBUINDO ENDEREÇOS:

            int var = 10;
            int *ptr = &var;

        AQUI, `ptr` ARMAZENA O ENDEREÇO DE MEMÓRIA DE `var`. O OPERADOR `&` É USADO PARA OBTER O ENDEREÇO DE MEMÓRIA 
        DE UMA VARIÁVEL.

        ACESSANDO VALORES:

            int valor = *ptr;

        AQUI, `valor` RECEBE O VALOR ARMAZENADO NO ENDEREÇO DE MEMÓRIA APONTADO POR `ptr`. O OPERADOR `*` É USADO 
        PARA DESREFERENCIAR O PONTEIRO, OU SEJA, ACESSAR O VALOR ARMAZENADO NAQUELE ENDEREÇO.

        PONTEIROS SÃO EXTREMAMENTE ÚTEIS EM C PARA UMA VARIEDADE DE TAREFAS, INCLUINDO ALOCAÇÃO DINÂMICA DE MEMÓRIA, 
        PASSAGEM DE PARÂMETROS POR REFERÊNCIA E MANIPULAÇÃO DE ARRAYS E STRINGS.

        O OPERADOR `&` TAMBÉM É USADO PARA PASSAR PARÂMETROS POR REFERÊNCIA EM FUNÇÕES.

        EXEMPLO:
        
            int n = 50;
            printf("%p\n", &n);
        
        SE DECLARA UMA VARIÁVEL INTEIRA `N` E A INICIALIZA COM O VALOR 50.
        E IMPRIME O ENDEREÇO DE MEMÓRIA DA VARIÁVEL `N` USANDO O ESPECIFICADOR DE FORMATO `%P`.
        `%P` É UM ESPECIFICADOR DE FORMATO USADO PARA IMPRIMIR O VALOR DE UM POINTER.
        O OPERADOR `&`, É USADO PARA OBTER O ENDEREÇO DE MEMÓRIA DE UMA VARIÁVEL.
        

    STRINGS

        EM C, STRINGS NÃO SÃO UM TIPO DE DADO PRIMITIVO COMO EM OUTRAS LINGUAGENS DE PROGRAMAÇÃO. EM VEZ DISSO, 
        STRINGS SÃO REPRESENTADAS COMO ARRAYS DE CARACTERES TERMINADOS COM UM CARACTERE NULO (`\0`).

        DECLARANDO STRINGS:

            char nome[] = "CS50";

        AQUI, `nome` É UM ARRAY DE CARACTERES QUE CONTÉM A STRING "CS50" E UM CARACTERE NULO (`\0`) NO FINAL.

        STRINGS E PONTEIROS:

        EM C, STRINGS SÃO FORTEMENTE RELACIONADAS A PONTEIROS. UM PONTEIRO PARA UM CHAR (`char *`) PODE SER USADO 
        PARA MANIPULAR STRINGS.

        EXEMPLO:

            char *nome = "CS50";

        AQUI, `nome` É UM PONTEIRO PARA UM CHAR QUE APONTA PARA A STRING "CS50". ESSA É UMA FORMA COMUM DE 
        DECLARAR STRINGS EM C.

        ACESSANDO E MODIFICANDO STRINGS:

        VOCÊ PODE USAR PONTEIROS PARA ACESSAR E MODIFICAR OS CARACTERES EM UMA STRING.

        EXEMPLO:

            char nome[] = "CS50";
            char *ptr = nome;
            ptr[0] = 'c';

        AQUI, `ptr` APONTA PARA O PRIMEIRO CARACTERE DA STRING `nome`. AO MODIFICAR `ptr[0]`, VOCÊ TAMBÉM MODIFICA 
        O PRIMEIRO CARACTERE DA STRING `nome`.

        POR QUE STRINGS NÃO SÃO UM TIPO DE DADO EM C?

        STRINGS NÃO SÃO UM TIPO DE DADO PRIMITIVO EM C PORQUE A LINGUAGEM FOI PROJETADA PARA SER SIMPLES E EFICIENTE. 
        AO USAR ARRAYS DE CARACTERES E PONTEIROS, C FORNECE UMA FORMA FLEXÍVEL E PODEROSA DE MANIPULAR STRINGS SEM 
        A SOBRECARGA DE UM TIPO DE DADO DEDICADO. ISSO TAMBÉM PERMITE QUE OS PROGRAMADORES TENHAM MAIS CONTROLE 
        SOBRE A MEMÓRIA E O DESEMPENHO DE SEUS PROGRAMAS.
    

    USANDO `typedef` COM PONTEIROS:

        O `typedef` EM C PERMITE CRIAR NOMES ALTERNATIVOS PARA TIPOS DE DADOS EXISTENTES, O QUE PODE TORNAR O CÓDIGO 
        MAIS LEGÍVEL E MANUTENÍVEL. ISSO É PARTICULARMENTE ÚTIL QUANDO SE TRATA DE PONTEIROS.

        EXEMPLO:

            typedef int* IntPtr;

        AQUI, `IntPtr` É DEFINIDO COMO UM NOME ALTERNATIVO PARA `int*`. ISSO SIGNIFICA QUE VOCÊ PODE USAR `IntPtr` 
        EM VEZ DE `int*` AO DECLARAR PONTEIROS PARA INTEIROS:

            IntPtr ptr1, ptr2;

        NESTE EXEMPLO, `ptr1` E `ptr2` SÃO DECLARADOS COMO PONTEIROS PARA INTEIROS USANDO O NOME ALTERNATIVO `IntPtr`.

    USANDO `typedef` COM STRINGS:

        ASSIM COMO COM PONTEIROS, VOCÊ PODE USAR `typedef` PARA CRIAR NOMES ALTERNATIVOS PARA STRINGS. EM C, STRINGS 
        SÃO REPRESENTADAS COMO PONTEIROS PARA CHAR (`char*`), E USAR `typedef` PODE TORNAR O CÓDIGO MAIS CLARO.

        EXEMPLO:

            typedef char* string;

        AQUI, `string` É DEFINIDO COMO UM NOME ALTERNATIVO PARA `char*`. ISSO SIGNIFICA QUE VOCÊ PODE USAR `string` 
        EM VEZ DE `char*` AO DECLARAR STRINGS:

            string nome = "CS50";

        NESTE EXEMPLO, `nome` É DECLARADO COMO UMA STRING USANDO O NOME ALTERNATIVO `string`.

        O `typedef` É UMA FERRAMENTA PODEROSA EM C QUE PODE AJUDAR A SIMPLIFICAR E CLARIFICAR O CÓDIGO, ESPECIALMENTE 
        QUANDO SE TRATA DE TIPOS COMPLEXOS. AO USAR `typedef`, VOCÊ PODE CRIAR NOMES MAIS SIGNIFICATIVOS E REDUZIR 
        A COMPLEXIDADE VISUAL DO SEU CÓDIGO.


    POINTER ARITHMETIC

        EM C, A ARITMÉTICA DE PONTEIROS PERMITE QUE VOCÊ REALIZE OPERAÇÕES MATEMÁTICAS COM PONTEIROS, COMO ADIÇÃO E 
        SUBTRAÇÃO. ISSO É PARTICULARMENTE ÚTIL AO TRABALHAR COM ARRAYS E STRINGS.

        EXEMPLO:

            char s[] = "CS50";
            printf("%c\n", *(s + 1)); // Imprime 'S'
            printf("%c\n", s[1]);     // Imprime 'S'
            printf("%s\n", s + 1);    // Imprime "S50"

        AQUI, `s` É UM ARRAY DE CARACTERES QUE CONTÉM A STRING "CS50". AO USAR `*(s + 1)`, ESTAMOS ACESSANDO O 
        SEGUNDO CARACTERE DA STRING (ÍNDICE 1), QUE É 'S'. ISSO É EQUIVALENTE A USAR `s[1]`. AO USAR `s + 1`, 
        ESTAMOS APONTANDO PARA A STRING A PARTIR DO SEGUNDO CARACTERE, RESULTANDO EM "S50".

        OUTRO EXEMPLO:

            int arr[] = {10, 20, 30, 40};
            int *ptr = arr;
            printf("%d\n", *(ptr + 2)); // Imprime 30
            printf("%d\n", arr[2]);     // Imprime 30

        AQUI, `arr` É UM ARRAY DE INTEIROS. AO USAR `*(ptr + 2)`, ESTAMOS ACESSANDO O TERCEIRO ELEMENTO DO ARRAY 
        (ÍNDICE 2), QUE É 30. ISSO É EQUIVALENTE A USAR `arr[2]`.

        A ARITMÉTICA DE PONTEIROS TAMBÉM PODE SER USADA PARA ITERAR SOBRE ARRAYS E STRINGS.

        EXEMPLO:

            char s[] = "CS50";
            char *ptr = s;
            while (*ptr != '\0') {
                printf("%c\n", *ptr);
                ptr++;
            }

        AQUI, `ptr` É UM PONTEIRO QUE INICIALMENTE APONTA PARA O PRIMEIRO CARACTERE DA STRING `s`. O LOOP `while` 
        IMPRIME CADA CARACTERE DA STRING ATÉ ENCONTRAR O CARACTERE NULO (`\0`), INCREMENTANDO `ptr` A CADA ITERAÇÃO.

        A ARITMÉTICA DE PONTEIROS É UMA FERRAMENTA PODEROSA EM C QUE PERMITE MANIPULAR DIRETAMENTE OS ENDEREÇOS DE 
        MEMÓRIA E TRABALHAR EFICIENTEMENTE COM ARRAYS E STRINGS. NO ENTANTO, É IMPORTANTE USAR ESSA FERRAMENTA COM 
        CUIDADO PARA EVITAR ERROS DE ACESSO À MEMÓRIA.


    STRING COMPARISON

        EM C, A COMPARAÇÃO DE STRINGS NÃO PODE SER FEITA USANDO OS OPERADORES DE IGUALDADE (`==`) OU DESIGUALDADE (`!=`) 
        COMO EM OUTRAS LINGUAGENS DE PROGRAMAÇÃO. ISSO OCORRE PORQUE ESSES OPERADORES COMPARARÃO OS ENDEREÇOS DE MEMÓRIA 
        DAS STRINGS, NÃO OS SEUS CONTEÚDOS. PARA COMPARAR O CONTEÚDO DE DUAS STRINGS, DEVEMOS USAR A FUNÇÃO `strcmp` 
        DA BIBLIOTECA PADRÃO `string.h`.

        A FUNÇÃO `strcmp`:

            int strcmp(const char *str1, const char *str2);

        A FUNÇÃO `strcmp` COMPARA DUAS STRINGS, `str1` E `str2`, E RETORNA UM VALOR INTEIRO BASEADO NA COMPARAÇÃO:

            - UM VALOR NEGATIVO SE `str1` FOR MENOR QUE `str2`.
            - ZERO SE `str1` FOR IGUAL A `str2`.
            - UM VALOR POSITIVO SE `str1` FOR MAIOR QUE `str2`.

        EXEMPLO:

            #include <stdio.h>
            #include <string.h>

            int main() {
                char *str1 = "CS50";
                char *str2 = "cs50";

                int result = strcmp(str1, str2);

                if (result == 0) {
                    printf("As strings são iguais.\n");
                } else {
                    printf("As strings são diferentes.\n");
                }

                return 0;
            }

        NESTE EXEMPLO, `strcmp` COMPARA AS STRINGS `str1` E `str2`. COMO A COMPARAÇÃO É SENSÍVEL A MAIÚSCULAS E 
        MINÚSCULAS, O RESULTADO INDICARÁ QUE `str1` É MENOR QUE `str2`.

        PARA COMPARAÇÕES INSENSÍVEIS A MAIÚSCULAS E MINÚSCULAS, PODEMOS USAR A FUNÇÃO `strcasecmp` (OU `_stricmp` 
        NO WINDOWS):

            int strcasecmp(const char *str1, const char *str2);

        EXEMPLO:

            #include <stdio.h>
            #include <string.h>

            int main() {
                char *str1 = "CS50";
                char *str2 = "cs50";

                int result = strcasecmp(str1, str2);

                if (result == 0) {
                    printf("As strings são iguais.\n");
                } else {
                    printf("As strings são diferentes.\n");
                }

                return 0;
            }

        NESTE EXEMPLO, `strcasecmp` COMPARA AS STRINGS `str1` E `str2` SEM DIFERENCIAR MAIÚSCULAS E MINÚSCULAS, 
        RESULTANDO EM UMA COMPARAÇÃO QUE INDICA QUE AS STRINGS SÃO IGUAIS.

        A COMPARAÇÃO DE STRINGS É UMA OPERAÇÃO COMUM EM C QUE REQUER O USO DE FUNÇÕES ESPECÍFICAS PARA GARANTIR 
        QUE O CONTEÚDO DAS STRINGS SEJA COMPARADO CORRETAMENTE.

    COPY DE STRINGS

        EM C, COPIAR UMA STRING PARA OUTRA VARIÁVEL PODE SER FEITO ATRAVÉS DA ATRIBUIÇÃO DE PONTEIROS. NO ENTANTO, 
        ISSO FAZ COM QUE AS DUAS VARIÁVEIS APONTEM PARA O MESMO ENDEREÇO DE MEMÓRIA, O QUE SIGNIFICA QUE QUALQUER 
        MODIFICAÇÃO EM UMA DAS VARIÁVEIS AFETARÁ A OUTRA.

        EXEMPLO:

            char *str1 = "CS50";
            char *str2 = str1;

            str2[0] = 'c';

            printf("%s\n", str1); // Imprime "cS50"
            printf("%s\n", str2); // Imprime "cS50"

        AQUI, `str1` E `str2` APONTAM PARA O MESMO ENDEREÇO DE MEMÓRIA. AO MODIFICAR `str2`, `str1` TAMBÉM É 
        MODIFICADA, POIS AMBAS APONTAM PARA A MESMA STRING.

        PARA EVITAR ESSE PROBLEMA, PODEMOS USAR A FUNÇÃO `strcpy` DA BIBLIOTECA PADRÃO `string.h` PARA COPIAR O 
        CONTEÚDO DE UMA STRING PARA OUTRA VARIÁVEL.

        EXEMPLO:

            #include <stdio.h>
            #include <string.h>

            int main() {
                char str1[] = "CS50";
                char str2[5];

                strcpy(str2, str1);

                str2[0] = 'c';

                printf("%s\n", str1); // Imprime "CS50"
                printf("%s\n", str2); // Imprime "cS50"

                return 0;
            }

        AQUI, `strcpy` COPIA O CONTEÚDO DE `str1` PARA `str2`, RESULTANDO EM DUAS STRINGS INDEPENDENTES. MODIFICAR 
        `str2` NÃO AFETARÁ `str1`.

    USANDO `malloc` PARA ALOCAÇÃO DINÂMICA DE MEMÓRIA

        EM C, PODEMOS USAR A FUNÇÃO `malloc` DA BIBLIOTECA PADRÃO `stdlib.h` PARA ALOCAR DINAMICAMENTE MEMÓRIA PARA 
        STRINGS. ISSO PODE SER ÚTIL PARA EVITAR O PROBLEMA DE PONTEIROS APONTANDO PARA O MESMO ENDEREÇO DE MEMÓRIA.

        EXEMPLO:

            #include <stdio.h>
            #include <stdlib.h>
            #include <string.h>

            int main() {
                char *str1 = "CS50";
                char *str2 = malloc(strlen(str1) + 1);

                if (str2 == NULL) {
                    printf("Erro ao alocar memória.\n");
                    return 1;
                }

                strcpy(str2, str1);

                str2[0] = 'c';

                printf("%s\n", str1); // Imprime "CS50"
                printf("%s\n", str2); // Imprime "cS50"

                free(str2);

                return 0;
            }

        AQUI, `malloc` ALOCA MEMÓRIA SUFICIENTE PARA ARMAZENAR A STRING `str1`, INCLUINDO O CARACTERE NULO (`\0`). 
        `strcpy` É USADO PARA COPIAR O CONTEÚDO DE `str1` PARA `str2`, RESULTANDO EM DUAS STRINGS INDEPENDENTES. 
        MODIFICAR `str2` NÃO AFETARÁ `str1`. APÓS USAR `str2`, A MEMÓRIA ALOCADA É LIBERADA COM `free`.

        USAR `malloc` PARA ALOCAÇÃO DINÂMICA DE MEMÓRIA É UMA FORMA EFICIENTE DE EVITAR PROBLEMAS DE PONTEIROS 
        APONTANDO PARA O MESMO ENDEREÇO DE MEMÓRIA E GARANTIR QUE AS STRINGS SEJAM INDEPENDENTES.
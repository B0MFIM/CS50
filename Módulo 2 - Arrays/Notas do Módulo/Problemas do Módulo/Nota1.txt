COMPILING

    COMPILAR (COMPILING) É CONVERTER NOSSO CÓDIGO EM 0'S E 1'S.

        CÓDIGO-FONTE -> COMPILADOR -> CÓDIGO DE MÁQUINA

    O COMPILADOR QUE NÓS USAMOS, SE CHAMA 'make', MAS O QUE ACONTECE POR TRÁS DELE E POR CONSEQUÊNCIA POR TRÁS
    DO QUE ESTÁ POR TRÁS DO 'make'?

    SABEMOS QUE 'make' COMPILA NOSSO CÓDIGO, MAS ESSA É UMA DAS MENTIRAS QUE CONTAMOS, POIS, NA VERDADE ELE ESTÁ
    EXECUTANDO AUTOMATICAMENTE UM COMPILADOR PARA VOCÊ, E O COMPILADOR QUE ELE EXECUTA SE CHAMA 'CLANG'. POR TRÁS 
    DO NOSSO COMANDO DE LINHA 'make hello.c' ESTÁ 'clang -o hello hello.c -lcs50'. UM POUCO MAIS LONGO E COMPLEXO, 
    MAS VAMOS DESTRINCHAR O COMPILADOR CLANG POR PARTES. POR EXEMPLO, PODEMOS, ASSIM COMO O 'MAKE' ESCREVERMOS 
    'CLANG HELLO.C', MAS ISSO NOS GERA NOSSO PRIMEIRO PROBLEMA.

    SE TENTARMOS EXECUTAR NOSSO PROGRAMA './hello' NOSSO TERMINAL NÃO IRÁ DETECTAR ESTE ARQUIVO, JUSTAMENTE PELO
    CLANG NÃO SER UM COMPILADOR TÃO AMIGAVEL QUANTO O MAKE. QUANDO COMPILAMOS 'clang hello.c' ELE, NA VERDADE, 
    ESTÁ CRIANDO UM ARQUIVO COMPILADO CHAMADO 'a.out' QUE ESTA COM NOSSO PROGRAMA, E PARA EXECUTA-LO, TERIAMOS 
    QUE ESCREVER './a.out'.

    E COMO NÓS NOMEAMOS ESSE ARQUIVO 'a.out' PARA O QUE QUISERMOS? NÓS USAREMOS O QUE CHAMAMOS DE "COMMAND LINES
    ARGUMENTS", QUE SÃO PALAVRAS ADICIONAIS OU NOTAÇÕES ABREVIADAS QUE DE ALGUMA FORMA MODIFICA O COMPORTAMENTO 
    DO NOSSO COMANDO DE LINHA. POR EXEMPLO, SE QUEREMOS NOMEAR NOSSO ARQUIVO COMPILADO DE FATO, USARIAMOS:

        'clang -o hello hello.C'

    O ARGUMENTO '-o hello' ESTA NOMEANDO NOSSO ARQUIVO COMPILADO, E COM ISSO PODERIAMOS EXECUTAR NOSSO PROGRAMA
    COMO JÁ SABEMOS FAZER './hello' E ELE EXECUTARIA NORMALMENTE.

    HÁ OUTRO PROBLEMA QUE PODE SER CAUSADO CASO NOSSO PROGRAMA ESTEJA USANDO UMA BIBLIOTECA QUE NÃO SEJA A PADRÃO
    DA LINGUAGEM C. POR EXEMPLO, A BIBLIOTECA 'cs50', SE APENAS USARMOS O COMANDO 'clang -o hello hello.C' E
    ESTIVERMOS USANDO A BIBLIOTECA 'cs50' NOSSO COMPILADOR IRÁ EXIBIR UM ERRO, POIS ELE NÃO ESTARÁ LOCALIZANDO
    AS FUNÇÕES QUE UTILIZAMOS DESSA BIBLIOTECA E NÃO DETECTARÁ A BIBLIOTECA DE FATO. PARA INDICARMOS ISSO, 
    USAMOS:

        'clang -o hello hello.c -lcs50'

    O ARGUMENTO '-lcs50' ESTÁ INFORMANDO AO NOSSO COMPILADOR QUE HÁ UMA BIBLIOTECA DESTE NOME QUE PRECISAR SER LIDA 
    E COMPILADA JUNTO COM O NOSSO CÓDIGO. COM ISSO, ELE COMPILARÁ NOSSO PROGRAMA SEM PROBLEMAS E PODEMOS EXECUTA-LO.
    SE NOSSO PROGRAMA TIVER MAIS BIBLIOTECAS, BASTA IR ADICINANDO NESSE COMANDO DE LINHA.

    COMO FALAMOS AO INÍCIO, 'make' AMIGAVELMENTE RODA TODO O COMANDO DE LINHA 'clang -o hello hello.c -lcs50', E OUTRAS
    COISAS INCLUSAS, DENTRO DELE. O QUE DEIXE AS COISAS MAIS SIMPLES PARA NÓS.

    MAS 'COMPILING' NÃO SIGNIFICA APENAS COMPILAR. COMPILAR É APENAS UM DOS QUATRO PROCESSOS PRINCIPAIS ENVOLVIDOS
    NA TRANSFORMAÇÃO DO NOSSO CÓDIGO EM 0'S E 1'S. POR TRÁS DO QUE CHAMAMOS DE 'COMPILING' ESTÁ:

        PREPROCESSING - É a etapa que converte para o nosso programa todas as linhas '#include' nos protótipos
                        que usaremos e usamos no nosso código, alem de outras coisas.

        COMPILING - É a etapa que converte nosso código-fonte em outro tipo de linguagem chamada 'assembly'.

        ASSEMBLING - É a etapa que de fato converte o código assembly para o código de máquina.

        LINKING - É a etapa de juntar todos os arquivos que usamos para nosso código em um unico arquivo compilado.
                  juntando assim, o arquivo hello.c, com o arquivo stdio.c (que chamamos através do include para o
                  nosso código) e o arquivo cs50.c (que também chamamos através do include), tudo em um único 
                  arquivo de 0's e 1's.

    COMO UMA NORMA ESTABELECIDA, USAMOS O TERMO 'COMPILING' PARA ABRANGER TODOS ESSES 4 PROCESSOS. PROCESSOS ESSE
    POR TRÁS CLANG QUE ESTÁ POR TRÁS DO MAKE.


DEBUGGING

    DEBUGGING, OU DEPURAÇÃO, É UMA FERRAMENTA QUE AJUDA O PROGRAMADOR ENCONTRAR ERROS LÓGICOS E PROGRAMÁTICOS 
    EM SEU CÓDIGO COMPILADO. 

    DEBUG50 É UM DEPURADOR DO CURSO CS50, QUE USAREMOS.
    BASTA DIGITAR O SEGUINTE COMANDO DE LINHA:

        'debug50 ./hello'

    E O DEPURADOR VAI SER EXECUTADO JUNTO COM O SEU CÓDIGO. CLARO QUE PARA ISSO DEVE-SE DEFINIR UM PONTO DE
    INTERRUPÇÃO EM SEU CÓDIGO, POR ONDE O DEPURADOR IRÁ "INTERROMPER" O SEU CÓDIGO PARA QUE VOCÊ VEJA CADA
    DETALHE DE LINHA PROGRAMADA POR VOCÊ.


MEMORY

    bool    - 1 byte
    int     - 4 bytes
    long    - 8 bytes
    float   - 4 bytes
    double  - 8 bytes
    char    - 1 byte
    string  - ? bytes
    ...

    CADA TIPO DE DADO APRESENTADO SE UTILIZA DE UM, OU MAIS, ESPAÇO DE MEMÓRIA DO NOSSO COMPUTADOR. PODEMOS
    REPRESENTAR ESSA MEMÓRIA COMO UMA GRADE DE 8X8, CADA QUADRADO REPRESENTARIA UM BYTE DE MEMÓRIA, OU SEJA,
    UM VALOR DO TIPO LONG ESTARIA OCUPADO UMA LINHA INTEIRA DE 8 BYTES DE MEMÓRIA DA NOSSA GRADE. ENQUANTO,
    UM TIPO CHAR ESTARIA USANDO APENAS 1 BYTE DESSA MEMÓRIA.

    SCORES.C

        int main(void)
        {
            int score1 = 72; // Essa e as outra duas variáveis estariam ocupando 4 bytes de memória.
            int score2 = 73;    O que daria num total de 12 bytes de memória sendo utilizadas.
            int score3 = 33;

            printf("Averege %f\n", (score1 + score2 + score3) / 3.0); // Se tivermos um número de ponto flutuante, 
                                                                         toda nossa conta será um valor do tipo float,
                                                                         não necessáriamente tendo que converte-los
                                                                         para float.
        }

    MAS E SE TIVERMOS MAIS VALORES 'SCORE' PARA SER SOMADOS? TERIAMOS QUE CRIAR OUTRAS VARIÁVEIS E ASSIM POR DIANTE.
    POREM, ESTARIAMOS GERANDO UM PROBLEMA DE REDUNDÂNCIA, UMA FRAGMENTAÇÃO DESNECESSÁRIA DO NOSSO CÓDIGO. POR ISSO,
    TEMOS UM TIPO DE SINTAXE QUE PODE ARMAZENAR QUANTAS "VARIÁVEIS/INFORMAÇÕES" FOREM NECESSÁRIAS, O QUE CHAMAMOS DE
    ARRAYS.


ARRAYS

    ARRAYS, OU MATRIZ, É UMA SEQUÊNCIA DE VALORES CONSECUTIVOS NA MEMÓRIA. PORTANTO, UM ARRAY É APENAS UM
    PEDAÇO DE MEMÓRIO QUE ARMAZENA VALORES CONSECUTIVOS, DA ESQUERDA PARA A DIREITA, DE CIMA PARA BAIXO.
    SEM LACUNAS, SEM FRAGMENTAÇÃO, DO SEU CÓDIGO COMO NO EXEMPLO ACIMA.

    ESSES ARRAYS EM C, PELO MENOS, FORNECERÃO UMA SINTAXE LIGEIRAMENTE NOVA:

        int scores[3];  // dê-me um array de tamanho 3

    AQUI ESTAMOS DEFININDO UMA VARIÁVEL, COMO OUTRAS, COM UM DIFERENCIAL DE QUE QUEREMOS TRÊS NÚMEROS INTEIROS 
    GUARDADOS NESSA VARIÁVEL, REPRESENTADO PELO '[3]' NA SINTAXE ACIMA. O QUE ESTOU FAZENDO É DIZENDO AO 
    COMPILADOR QUE ME DÊ ESPAÇO SUFICIENTE PARA NÃO UM, NÃO DOIS, MAS TRÊS INTEIROS NO TOTAL. 

    AGORA ATRIBUIR VALORES A ESSAS VARIÁVEIS É QUASE O MESMO, MAS A SINTAXE É SEMELHANTE A ESTA:

        scores[0] = 72;     // entre neste array na posição '0' e atribua o valor '72'.
        scores[1] = 73;     // entre neste array na posição '1' e atribua o valor '73'.
        scores[2] = 33;     // entre neste array na posição '2' e atribua o valor '33'.

    AAGORA VOLTEMOS AO NOSSO CÓDIGO:

        int main(void)
        {
            int scores[3]; // definindo um array
            scores[0] = 72; 
            scores[1] = 73;    
            scores[2] = 33;

            printf("Averege %f\n", (scores[0] + scores[1] + scores[2]) / 3.0);
        }

    PERCEBA QUE TODO ARRAY, SEMPRE COMEÇA 'CONTANDO' A PARTIR DE ZERO, OU SEJA, SE TENHO UM ARRAY DE TAMANHO 4,
    CONTARIAMOS '0, 1, 2, 3', PARA AS 4 POSIÇÕES, ASSIM COMO FIZEMOS COM SCORES[3] ACIMA, E SE TENTARMOS
    EXTRAPOLAR O MÁXIMO DE POSIÇÕES QUE DEFINIMOS, ALGUNS PROBLEMAS IRIAM SE GERADOS.


STRINGS

    
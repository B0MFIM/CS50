COMMAND LINE ARGUMENTS

    ATÉ AGORA, NOSSOS PROGRAMAS SEMPRE COMEÇARAM COM 'INT MAIN(VOID)'. COLETAMOS INFORMAÇÕES DO USUÁRIO QUANDO
    PRECISAMOS DELAS EM NOSSOS PROGRAMAS, COMO O PROGRAMA 'MARIO', POR MEIO DE PROMPTS NO PROGRAMA. NÃO PRECISAMOS
    MODIFICAR A DECLARAÇÃO MAIN, PORQUE EM VEZ DISSO, DENTRO DE MAIN, APENAS FAZEMOS, POR EXEMPLO, UMA CHAMADA DA 
    FUNÇÃO 'GET_INT'. 

    HÁ OUTRA FORMA, E SE QUISERMOS QUE NOSSOS USUÁRIOS SEJAM CAPAZES DE FORNECER DADOS PARA O NOSSO PROGRAMA EM 
    TEMPO DE EXECUÇÃO, EM VEZ DE QUANDO O PROGRAMA ESTIVER EM EXECUÇÃO, UMA DISTINÇÃO SUTIL, MAS AS VEZES BEM ÚTIL,
    PRECISAMOS DE UMA NOVA FORMA DE DECLARAR 'MAIN'. NÃO PODEMOS USAR 'INT MAIN(VOID)' SE QUISERMOS COLETAR OUTROS
    DADOS DA LINHA DE COMANDO QUANDO O USUÁRIO EXECUTA O PROGRAMA, PORTANTO, ARGUMENTOS DE LINHA DE COMANDO.

    PARA COLETAR ESSES ARGUMENTOS DE LINHA DE COMANDO DO USUÁRIO, ALTERE SUA DECLARAÇÃO DE MAIN PARA:

        int main(int argc, string argv[])
        {

        }

        ESTAMOS PASSANDO DOIS PARÂMETROS, OU ARGUMENTOS, OU ENTRADAS, PARA O MAIN. UM INTEIRO CHAMADO 'ARGC' E UM
        ARRAY DO TIPO STRING. E ESSES DOIS ARGUMENTOS, PERMITEM QUE VOCÊ SAIBA QUAIS DADOS O USUÁRIO FORNECEU NA
        LINHA DE COMANDO E QUANTAS COISAS ELE FORNECEU NA LINHA DE COMANDO.

        argc -> significa a contagem de argumentos digitados da linha de comando.

        argv[] -> é o vetor (array) de argumento, que é um array que armazena strings, uma string por elemento
                  digitado na linha de comando.

        PORTANTO:

            ./hello         ->  argc = 1;  &  argv[] = {./hello};

            ./hello Eve 22  ->  argc = 3;  &  argv[] = {./hello, Eve, 22};

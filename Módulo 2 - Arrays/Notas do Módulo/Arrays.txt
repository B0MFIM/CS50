ARRAYS

    ARRAY SÃO UMA ESTRUTURA DE DADOS REALMENTE FUNDAMENTAL PARA QUALQUER LINGUAGEM DE PROGRAMAÇÃO QUE VOCÊ USARÁ.
    
    USAMOS ARRYAS PARA VALORES DO MESMO TIPO DE DADOS EM LOCAIS DE MEMÓRIA CONTÍGUOS. OU SEJA, É UMA MANEIRA DE
    AGRUPARMOS UM MONTE DE NÚMEROS INTEIROS OU UM MONTE DE CARACTERES, OU FLOATS, NA MEMÓRIA BEM PRÓXIMOS UNS DOS 
    OUTROS E TRABALHAR COM ELES SEM TER QUE DAR A UM SEU PRÓPRIO NOME EXCLUSIVO, O QUE PODE SER COMPLICADO DEPOIS 
    DE UM TEMPO.

    UMA ANALOGIA:

        UM ARRAY É UM BLOCO DE MEMÓRIA CONTÍGUA, DA MESMA FORMA QUE UM BANCO DE CORREIO EM SUA AGÊNCIA POSTAL É UM
        GRANDE ESPAÇO NA PAREDE DA AGÊNCIA POSTAL. 
    
        ARRAYS FORAM DÍVIDIDAS EM PEQUENOS BLOCOS DE ESPAÇO DE TAMANHO IDÊNTICO, CADA UM DOS QUAIS É CHAMADO DE 
        'ELEMENTO', DA MESMA FORMA QUE A PAREDE DA AGÊNCIA DOS CORREIOS FOI DIVIDIDA EM PEQUENOS BLOCOS DE ESPAÇO 
        DO MESMO TAMANHO IDÊNTICO, QUE CHAMAMOS DE CAIXA POSTAL. 
        
        CADA ELEMENTO DO ARRAY PODE ARMAZENAR UMA CERTA QUANTIDADE DE DADOS, ASSIM COMO CADA CAIXA POSTAL É CAPAZ 
        DE ARMAZENAR UMA CERTA QUANTIDADE DE CORRESPONDÊNCIA.

        O QUE PODE SER ARMAZENADO EM CADA ELEMENTO DO ARRAY SÃO VARIÁVEIS DO MESMO TIPO DE DADO, COMO INT OU CHAR,
        ASSIM COMO NA SUA CAIXA POSTAL, VOCÊ SÓ PODE COLOCAR COISAS DO TIPO SEMELHANTE, COMO CARTAS E PACOTES PEQUENOS.

        POR ÚLTIMO, PODEMOS ACESSAR CADA ELEMENTO DO ARRAY DIRETAMENTE PELO NÚMERO DO ÍNDICE, ASSIM COMO PODEMOS
        ACESSAR NOSSA CAIXA POSTAL SABENDO O NÚMERO DA SUA CAIXA POSTAL.

    EM C, ELEMENTOS DE UM ARRAY SÃO INDEXADOS A PARTIR DE 0. PORTANTO SE UM ARRAY CONSISTE EM N ELEMENTOS, O PRIMEIRO
    ELEMENTO DESSE ARRAY ESTÁ LOCALIZADO NO ÍNDICE 0, E O ÚLTIMO ELEMENTO DESSE ARRAY ESTÁ LOCALIZADO EM 'N-1'. OU
    SEJA, SE NOSSO ARRAY POSSUI 50 ELEMENTOS, O PRIMEIRO ELEMENTO É LOCALIZADO NO ÍNDICE 0 E O ÚLTIMO NO ÍNDICE 49.

    INFELIZMENTE, OU FELIZMENTE, C É MUITO TOLERANTE AQUI, ISSO NÃO IMPEDIRÁ QUE VOCÊ SAIA DOS LIMITES DO SEU ARRAY.
    VOCÊ PODE ACESSAR O ELEMENTO -3 OU 59, MESMO SE SEU ARRAY TIVER APENAS 50 ELEMENTOS, ISSO NÃO VAI INTERROMPER
    A SUA COMPILAÇÃO, MAS ISSO PODE GERAR UMA GRANDE FALHA DE SEGMENTAÇÃO SE COMEÇAR A ACESSAR A MEMÓRIA QUE ESTÁ 
    FORA DOS LIMITES DO QUE VOCÊ PEDIU AO SEU PROGRAMA. PORTANTO TENHA CUIDADO.

ARRAY DECLARATION

    CODIFICAMOS UM ARRAY DA SEGUINTE FORMA:

        type array[size];

            type - é que tipo de de variável você deseja que cada elemento do array seja.

            array - é como você deseja chamar seu array.

            size - é quantos elementos você quer que seu array tenha.

    UM EXEMPLO:

        int student_grades[40]; 

        // isso declara um array chamado 'student_grades' que vai armazenar 40 elementos do tipo inteiro.

    SE VOCÊ PENSAR EM CADA ELEMENTO DE UM ARRAY DO TIPO DATA-TYPE, POR EXEMPLO, UM ÚNICO ELEMENTO DE UM ARRAY DO
    TIPO INT, DA MESMA FORMA QUE VOCÊ PENSARIA EM QUALQUER OUTRA VARIÁVEL DO TIPO INT, TODAS AS OPERAÇÕES FAMILIARES
    QUE DISCUTIMOS ANTERIORMENTE FARÁ SENTIDO.

    POR EXEMPLO:

        bool truthtable[10];

        truthtable[2] = false;
        if(truthtable[7] == true)
        {
            printf("TRUE!\n");
        }
        truthtable[10] = true;

        AQUI DECLARAMOS UM ARRAY 'TRUTHTABLE' DO TIPO BOOL COM 10 POSIÇÕES, QUE CONSISTE EM ESPAÇO PARA 10 BOOLEANOS.
        E ENTÃO, ASSIM COMO PODERIAMOS SIMPLESMENTE ATRIBUIR UM VALOR A QUALQUER OUTRA VARIÁVEL DO TIPO BOLEAN, 
        PODERIAMOS DIZER ALGO COMO 'TRUTHTABLE[2] = FALSE;' (O TERCEIRO ELEMENTO DE TRUTHTABLE), E ASSIM COMO QUALQUER
        OUTRA VARIÁVEL A DECLARAMOS, E PODEMOS FAZER ISSO PARA TODAS AS OUTRAS 9 POSIÇÕES DESTE ARRAY. E COMO MOSTRADO,
        PODEMOS UTILIZA-LOS EM CONDIÇÕES (E TAMBÉM EM LOOPS).

        PERCEBA QUE PODEMOS DECLARA 'TRUTHTABLE[10] = TRUE', MAS ISSO É MUITO PERIGOSO, POR QUE LEMBRE-SE, TEMOS UM 
        ARRAY DE 10 BOOLEANOS E NÃO 11 (POIS CONTAMOS POSIÇÕES A PARTIR DE 0 E NÃO 1), POIS ENTÃO O ÍNDICE MAIS ALTO
        QUE O COMPILADOR NOS FORNECEU É '9'. O PROGRAMA VAI COMPILAR O 'TRUTHTABLE[10]' MAS SE EXISTIR ALGO A MAIS
        NA MÉMORIA ONDE ESPERARIAMOS QUE O TRUTHTABLE 10 FOSSE, PODERIAMOS SOFRE UMA FALHA DE SEGMENTAÇÃO. PODEMOS
        ESCAPAR IMPUNES, MAS, EM GERAL, É MUITO PERIGOSO.

DECLARING AND INITIALIZING

    AGORA, QUANDO VOCÊ DECLARA E INICIALIZA UM ARRAY SIMULTANEAMOENTE, HÁ NA VERDADE UMA SINTAXE MUITO ESPECIAL QUE
    VOCÊ PODE USAR PARA PREENCHER O ARRAY COM SEUS VALORES INICIAIS. PODE SER COMPLICADO DECLARAR UM ARRAY DE 100
    POSIÇÕES, E TER QUE DIZER QUE O ELEMENTO 0 É ISSO, O 1 É AQUILO, E ASSIM POR DIANTE. SE FOR UM ARRAY PEQUENO,
    PODERIAMOS FAZER ALGO ASSIM:

        // instantiation syntax
        bool truthtable[] = {false, true, true};

        // individual element syntax
        bool truthtable[3];
        truthtable[0] = false;
        truthtable[1] = true;
        truthtable[2] = true;

        ESSAS DUAS FORMAS DE CODIFICAÇÃO DE UM ARRAY PRODUZIRAM EXATAMENTE O MESMO ARRAY COM 3 POSIÇÕES. NO 
        'INSTANTIOATION' NÃO É NECESSÁRIO INDICAR O TAMANHO DO ARRAY DE ANTEMÃO. O COMPILADOR É INTELIGÊNTE
        O SUFICIENTE PARA SABER QUE VOCÊ REALMENTE DESEJA UM ARRAY DE 3 POIÇÕES, PORQUE VOCÊ COLOCA TRÊS 
        ELEMENTOS À DIREITA DO SINAL DE IGUAL.

    AGORA, SE FOR UM ARRAY MUITO GRANDE, COM 100 POSIÇÕES, SE RECOMENDO QUE USEMOS UM LOOP. POR EXEMPLO:

        float array[100];
        for (int i = 0; i < array; i++)
        {
            array[i] = get_int("Posição %i: ", i);
        }

ARRAY DIMENSIONS

    OS ARRAYS NÃO ESTÃO RESTRITOS A UMA ÚNICA DIMENSÃO. NA VERDADE, VOCÊ PODE TER QUANTOS ESPECIFICADORES LATERAIS
    DESEJAR. 

    POR EXEMPLO, SE VOCÊ QUER CRIAR UM TABULEIRO PARA O JOGO BATTLESHIP, QUE É UM JOGO JOGADO COM PINOS NA GRADE
    DE 10 POR 10, VOCÊ PODERIA CRIAR UMA MATRIZ COMO ESTA:

        bool battleship[10][10];

    E VOCÊ PODE QUERER INTERPRETAR ISSO EM SUA MENTE COMO UMA GRA DE CÉLULAS DE 10 POR 10. AGORA, NA VERDADE, NA 
    MEMÓRIA, ELE PERMANECE NA MEMÓRIA UM ARRAY UNIDIMENSIONAL DE 100 ELEMENTOS. E ISSO, DE FATO, VALE SE VOCÊ TIVER
    TRÊS DIMENSÕES, QUATRO OU CINCO. NA VERDADE, ELE APENAS MULTIPLICA TODOS OS ÍNDICES - OU TODOS OS ESPECIFICADORES
    DE TAMANHO - JUNTOS, E VOCÊ OBTEM UMA MATRIZ UNIDIMENSIONAL DESSE TAMANHO.

    MAS EM TERMOS DE ORGANIZAÇÃO, VISUALIZAÇÃO E PERCEPÇÃO HUMANA, PODE SER MUITO MAIS FÁCIL TRABALHAR COM UMA GRADE
    SE VOCÊ ESTIVER TRABALHANDO EM UM JOGO COMO BATTLESHIP OU ALGO PARECIDO. É UMA ÓTIMA ABSTRAÇÃO, EM VEZ DE TER 
    QUE PENSAR EM UM TABULEIRO DE JOGO DA VELHA COMO UMA LINHA DE NOVE QUADRADOS OU EM UM TABULEIRO DE NAVAL COMO 
    UMA LINHA DE 100 QUADRADOS. UMA GRADE DE 10 POR 10 OU UMA GRADE DE 3 POR 3 É PROVALVEMENTE MUITO MAIS FÁCIL DE
    PERCEBER.

ARRAY INDIVIDUAL ELEMENTS

    PODEMOS TRATAR CADA ELEMENTO INDIVIDUAL DO ARRAY COMO UMA VARIÁVEL. VIMOS ISSO ANTERIORMENTE. MAS NÃO PODEMOS
    TRATAR ARRAYS INTEIROS COMO VARIÁVEIS. NÃO PODEMOS, POR EXEMPLO, ATRIBUI UMM ARRAY PARA OUTRO ARRAY USANDO O 
    OPERADOR DE ATRIBUIÇÃO.

    O QUE PODERIAMOS FAZER, É USAR UM LOOP, PARA COPIAR TUDO DE UM ARRAY PARA OUTRO COPIANDO INDIVIDUALMENTE CADA 
    UM DOS ELEMENTOS POR VEZ, UM DE CADA VEZ. 

    POR EXEMPLO:

        int foo[5] = {1, 2, 3, 4, 5};
        int bar[5];

        // bar = foo; -> isso não funcionaria

        for (int i = 0; i < 5; i++)
        {
            bar[i] = foo[i];
        }

        ASSIM, BAR RESULTARIA NA MESMA MATRIZ QUE FOO.

ARRAYS NÃO SEGUEM A REGRA DE 'PASSED BY VALUE'

    RELEMBRANDO DA REGRA DE 'PASSED BY VALUE' DAS VARIÁVEIS E ESCOPO, QUE SIGNIFICA QUE ESTAMOS FAZENDO UMA CÓPIA
    DA VARIÁVEL QUE ESTA SENDO PASSADA. A FUNÇÃO CHAMADA, CALLER, QUE ESTÁ RECEBENDO A VARIÁVEL, NÃO OBTEM A VARIÁVEL
    EM SI. ELA OBTEM SUA PRÓPRIA CÓPIA LOCAL PARA TRABALHAR.

    ARRAYS, CLARO, NÃO OBEDECEM ESSA REGRA. EM VEZ DISSO, O QUE CHAMAMOS ISSO É 'PASSED BY REFERENCE'. O RECEPTOR, 
    CALLEE, REALMENTE RECEBE O ARRAY. ELE NÃO RECEBE SUA PRÓPRIA CÓPIA LOCAL. ISSO OCORRE, POIS NÃO FAZ SENTIDO 
    FAZER UMA CÓPIA DE UMA ARRAY, AINDA MAIS SE ELE FOR LONGO, SÓ DARIA MAIS TRABALHO PRO PROGRAMA COMPILAR ISSO.
    E APENAS O PASSAMOS POR REFERÊNCIA. NÓS APENAS CONFIAMOS NESSA FUNÇÃO PARA NÃO QUEBRAR NADA. 

    ENTÃO O QUE SIGNIFICA QUANDO O RECEPTOR MANIPULA OS ELEMENTOS DO ARRAY? O QUE ACONTECE? 

    AQUI ESTÁ MAIS UM EXEMPLO:

        void set_array(int array[4]);
        void set_int(int x);

        int main(void)
        {
            int a = 10;
            int b[4] = {0, 1, 2, 3};
            set_int(a);
            set_array(b);
            printf("%d %d\n", a, b[0]);
        }

        void set_array(int array[4])
        {
            array[0] = 22;
        }

        void set_int(int x)
        {
            x = 22;
        }

        NESSE EXEMPLO, RELEMBRANDO AGORA DAS REGRAS 'PASSED BY VALUE' E 'PASSED BY REFERENCE', TEREMOS AO FINAL
        UMA EXIBIÇÃO DO PRINTF DE '10 22' POIS 'A' MANTERIA SEU VALOR DE 10, POIS A FUNÇÃO 'SET_INT' ESTÁ ALTERANDO
        UMA CÓPIA SUA, O QUE NÃO ACONTECE COM O ARRAY B[4], POIS A FUNÇÃO 'SET_ARRAY' NÃO CRIA UMA CÓPIA DELE, APENAS
        O RECEBE COMO REFERÊNCIA, 'ARRAY[4]', E SE HÁ ALTERAÇÃO DESTE ARRAY DENTRO DA FUNÇÃO, A ALTERAÇÃO VAI PERMANCER
        PARA O 'ARRAY B[4]'.
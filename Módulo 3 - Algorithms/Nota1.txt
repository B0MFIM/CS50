LINEAR SEARCH

    SEMPRE QUE HÁ A PESQUISA DE DADOS DE UMA MATRIZ DA ESQUERDA PARA A DIREITA, OU DA DIREITA PARA A ESQUERDA,
    NÓS CHAMAMOS ISSO DE PESQUISA LINEAR, POR QUE ESTAMOS ANDANDO EM UMA LINHA NÃO IMPORTA QUAL DIREÇÃO ESTEJA
    INDO. 
    
    VIMOS UM EXMPLO DISSO NO MÓDULO 0, QUANDO FALAMOS DE MANEIRAS DE ENCONTRAR UM NÚMERO NUMA LISTA TELEFÔNICA.


BINARY SEARCH

    SEMPRE QUE HÁ A PESQUISA DE DADOS DE UMA MATRIZ, INDO DA METADE PARA OUTRA METADE E ASSIM POR DIANTE, NÓS
    CHAMAMOS ISSO DE PESQUISA BINÁRIA.

    VIMOS UM EXMPLO DISSO NO MÓDULO 0, QUANDO FALAMOS DE MANEIRAS DE ENCONTRAR UM NÚMERO NUMA LISTA TELEFÔNICA.


RUNNING TIME // BIG O NOTATION // Ω NOTATION // Θ NOTATION

    MUITAS VEZES, OS ALGORITMOS QUE ESCREVEMOS OU USAMOS PODEM SER DESCRITOS COMO SENDO DA ORDEM DE UM DOS SEGUINTES
    RUNNUNG TIME:

        O(n²) -> Significa que o algoritmo leva um tempo de execução quadrático, 'n' coisas fazendo 'n' coisas. 

        O(n log n) -> // n log n

        O(n) -> Significa que o algoritmo leva um tempo de execução linear, um passo a passo para cada número de coisas. 

        O(log n) -> // Logarítmico

        O(1) -> Significa que o algoritmo leva um tempo de execução constante, não importando o número de coisas do código.

        * 'n' é o que representa o número de coisas que esteja fazendo no código.
        
        * As fórmulas matemáticas dentro dos parênteses descrevem, em função do tamanho dessa entrada, o quão rápido
        ou lento o algoritmo será.

    'BIG O NOTATION', REPRESENTA O LIMITE SUPERIOR DO ALGORITMO, QUE SIGNIFICA QUANTOS PASSOS, NO PIOR DOS CASOS, UM 
    ALGORITMO PODE DAR. MAS NEM SEMPRE QUEREMOS FALAR SOBRE COISAS EM TERMOS DE LIMITE SUPERIOR.

    ENTÃO, AS VEZES É ÚTIL SABER, NO MELHOR DOS CASOS, QUANTOS PASSOS UM ALGORITMO PODE EXECUTAR, PARA ISSO USAMOS
    A NOTAÇÃO Ω (OMEGA), QUE REPRESENTA O LIMITE INFERIOR DO ALGORITMO, É EXATAMENTE A MESMA IDEIA DO BIG O, MAS 
    USAMOS UM SÍMBOLO DIFERENTE PARA UMA IDEIA DIFERENTE.

        Ω(n²) -> Quadrático

        Ω(n log n) -> N log N

        Ω(n) ->  Linear

        Ω(log n) -> Logarítmico

        Ω(1) -> Constante

    'Ω NOTATION', REPRESENTA O LIMITE INFERIOR DO ALGORITMO, QUE SIGNIFICA QUANTOS PASSOS, NO MELHOR DOS CASOS, UM 
    ALGORITMO PODE DAR.

    PARA CASOS DE QUE O 'BIG O NOTATION' E 'Ω NOTATION' SEJAM IGUAIS PARA O ALGORITMO, NÓS USAMOS OUTRO TIPO DE
    NOTAÇÃO, O 'Θ NOTATION', QUE REPRESENTA ESSA IGUALDADE, QUE NEM SEMPRE É O CASO, MAS PODE SER, ENTÃO VOCÊ PODE
    DIZER QUE O ALGORITMO ESTÁ EM THETA.

        Θ(n²) -> Quadrático

        Θ(n log n) -> N log N

        Θ(n) ->  Linear

        Θ(log n) -> Logarítmico

        Θ(1) -> Constante

    'Θ NOTATION', REPRESENTA QUE O LIMITE INFERIOR E SUPERIOR DO ALGORITMO SÃO IGUAIS, OU SEJA, NO MELHOR E NO PIOR
    DOS CASOS O ALGORITMO LEVA O MESMO NÚMERO DE PASSOS.


SEARCH.C 

    int main(void)
    {
        int numbers[] = {20, 500, 10, 5, 100, 1, 50};
        int n = get_int("Number: ");
        for (int i = 0; i < 7; i++)
        {
            if (numbers[i] == n)
            {
                printf("Found\n");
                return 0;
            }
        }
        printf("Not found\n");
        return 1;
    }

    NO PROGRAMA ACIMA, NÓS USAMOS UM ALGORITMO DE BUSCA DE FORMA LINEAR PARA ENCONTRAR UM DENTERMINADO NÚMERO, DIGITADO
    PELO USUÁRIO, QUE ESTEJA, OU NÃO DENTRO DO ARRAY.

    E SE APLICARMOS ISSO PARA UM ARRAY DE STRINGS:

    int main(void)
    {
        string strings[] = {"banana", "abacaxi", "melancia", "manga", "cebola", "cenoura", "uva"};
        string s = get_string("Number: ");
        for (int i = 0; i < 7; i++)
        {
            if (strings[i] == s)
            {
                printf("Found\n");
                return 0;
            }
        }
        printf("Not found\n");
        return 1;
    }

    MAS PERCEBA QUE HÁ UM BUG NO RESULTADO DO PROGRAMA POIS ELE SEMPRE RESPONDERÁ "NOT FOUND", POR QUE? PORQUE NÃO SE
    PODE COMPARAR STRINGS IGUAL COMPARAMOS NÚMEROS, NESSE CASO TERIAMOS QUE USAR UMA FUNÇÃO DA BIBLIOTECA STRING.H QUE
    FAZ ESSA COMPARAÇÃO PARA NÓS:

    int main(void)
    {
        string strings[] = {"banana", "abacaxi", "melancia", "manga", "cebola", "cenoura", "uva"};
        string s = get_string("Number: ");
        for (int i = 0; i < 7; i++)
        {
            if (strcmp(strings[i], s) == 0) // A função retorna 0, para caso a comparação seja válida.
            {
                printf("Found\n");
                return 0;
            }
        }
        printf("Not found\n");
        return 1;
    }


DATA STRUCTURES

    O CÓDIGO ABAIXO FUNCIONA PERFEITAMENTE, MAS TEMOS UM CERTO PROBLEMA A SER TRATADO, QUE É A FORMA QUE NOSSOS DADOS
    SÃO ARMAZENADOS, ESSA FORMA NÃO É ADEQUADA PARA O QUE QUEREMOS FAZER, NO CASO, UMA LISTA TELEFÔNICA.

    int main(void)
    {
        string names[] = {"Eve", "Alexandre", "José"};
        string numbers[] = {"+55 00 00000-0000", "+55 11 11111-1111", "+55 22 22222-2222"};

        string name = get_string("Name: ");

        for (int i = 0; i < 3; i++)
        {
            if (strcmp(names[i], name) == 0)
            {
                printf("Found %s\n", numbers[i]);
                return 0;
            }
        }
        printf("Not found\n");
        return 1;
    }

    ARRAYS PARA ESSE TIPO DE ALGORITMO SÃO SIMPLISTAS DEMAIS, O QUE SIGNIFICA ARMAZENAR COISAS UMA APÓS A OUTRA, DE
    FORMA CONTÍGUA, NA MEMÓRIA. PARA ESSE CASO, NÃO É UMA ESTRUTURA DE DADOS MUITO ADEQUADA. 

    PARA ISSO TEMOS UMA OUTRA NOVA SINTAXE QUE PODERIAMOS USAR, CHAMADA 'STRUCT', PARA QUE POSSAMOS CRIAR NOSSA PRÓPRIA
    ESTRUTURA DE DADOS, QUE REALMENTE POSSUI UMA ESTRUTURA, QUE POSSAM SER DUAS OU MAIS COISAS, SEJA STRING, INTEIROS, 
    E OUTROS TIPOS DE DADOS. VEJAMOS ESSA ESTRUTURA:

        typedef struct // Significa "definir tipo - inventar tipo de dados"
        {
            // Aqui dentro você pode definir todo tipo de dado que você quer associar a essa estrutura.
            string name;
            string number;
        }
        person; // Aqui você define o nome dessa estrutura

    COM ISSO EM MENTE, PODEMOS REESCREVER O CÓDIGO ANTERIOR NO SEGUINTE:

        typedef struct // Definindo uma estrutura de dados
        {
            string name;    // definindo um dos tipos de dados da estrutura
            string number;
        }
        person; // Definindo o nome da estrutura de dados

        int main(void)
        {
            person people[3]; // Definindo um array do tipo de dado 'person' (da estrutura que criamos) de 3 posições

            people[0].name = "Eve";                     // Definindo dado name da posição 0
            people[0].number = "+55 00 00000-0000";     // Definindo dado number da posição 0

            people[1].name = "Alexandre";               // Definindo dado name da posição 1
            people[1].number = "+55 11 11111-1111";     // Definindo dado number da posição 1

            people[2].name = "José";                    // Definindo dado name da posição 2
            people[2].number = "+55 22 22222-2222";     // Definindo dado number da posição 2

            string name = get_string("Name: ");         // Recebe um nome do usuário

            for (int i = 0; i < 3; i++)
            {
                if (strcmp(people[i].name, name) == 0)  // Comparando dados name da estrutura person com a variável name
                {
                    printf("Found %s\n", people[i].number); // Exibe o número caso encontre o nome dentro da estrutura
                    return 0;
                }
            }
            printf("Not found\n");
            return 1;
        }


SELECTION SORT

    